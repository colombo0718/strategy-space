<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Emoji Dino Runner</title>
  <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ¦–</text></svg>">
  <script src="https://unpkg.com/konva@8.4.0/konva.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    /* Konva çš„å®¹å™¨å¤§å°äº¤çµ¦ JS æ§åˆ¶ */
    #container {
      background: #fff;
    }
  </style>
</head>
<body>
<div id="container"></div>

<script>
  // ===== éŠæˆ²é‚è¼¯åº§æ¨™ï¼ˆå›ºå®šè§£æåº¦ï¼‰ =====
  const GAME_W = 960;
  const GAME_H = 540;
  const GROUND_Y = 360;     // åœ°é¢é«˜åº¦ï¼ˆå¾€ä¸ŠæŠ¬ä¸€é»ï¼‰
  const GRAVITY = 0.6;
  const JUMP_VELOCITY = -11;
  const GAME_SPEED = 5;

  const SHOW_HITBOX = true; // é¡¯ç¤ºç¢°æ’æ¡†æ–¹ä¾¿èª¿æ•´
  const EMOJI_FONT = 'Arial, "Apple Color Emoji", "Segoe UI Emoji", sans-serif';

  const container = document.getElementById('container');

  const stage = new Konva.Stage({
    container: 'container',
    width: GAME_W,
    height: GAME_H,
  });

  const gameLayer = new Konva.Layer(); // åœ°é¢ã€æé¾ã€éšœç¤™ç‰©
  const uiLayer = new Konva.Layer();   // åˆ†æ•¸ã€æŒ‰éˆ•ã€GameOver
  stage.add(gameLayer);
  stage.add(uiLayer);

  // ===== åœ°é¢ç·š =====
  const groundLine = new Konva.Line({
    points: [0, GROUND_Y + 20, GAME_W, GROUND_Y + 20],
    stroke: '#999',
    strokeWidth: 2,
  });
  gameLayer.add(groundLine);

  // ===== æé¾ç‰©ä»¶ï¼ˆemoji ğŸ¦–ï¼‰ =====
  const DINO_FONT_SIZE = 40;
  let runPhase = 0; // ç”¨ä¾†åšè·‘æ­¥æ™ƒå‹•å‹•ç•«

  const dino = {
    x: 220,            // é ä¸­é–“ä¸€é»
    y: GROUND_Y,
    vy: 0,
    onGround: true,
    fontSize: DINO_FONT_SIZE,
    hitW: 40,
    hitH: 40,
    group: null,       // è£ sprite çš„ groupï¼ŒåŸé»åœ¨è…³åº•
    sprite: null,
    hitbox: null,
  };

  // ä»¥è…³åº•ç‚ºåŸé»çš„ group
  dino.group = new Konva.Group({
    x: dino.x,      // è…³åº•ä½ç½®
    y: dino.y,
  });
  gameLayer.add(dino.group);

  // çœŸæ­£çš„ emoji ç•«åœ¨ group è£¡
  dino.sprite = new Konva.Text({
    x: -dino.fontSize / 2,   // è®“è…³åº•åœ¨ (0,0)
    y: -dino.fontSize,
    text: 'ğŸ¦–',
    fontSize: dino.fontSize,
    fontFamily: EMOJI_FONT,
  });
  dino.group.add(dino.sprite);

  // æ°´å¹³é¡åƒ ğŸ¦–ï¼ˆåªå½±éŸ¿ spriteï¼Œä¸å‹• groupï¼‰
  (function mirrorDino() {
    const w = dino.sprite.width();
    dino.sprite.offsetX(w);
    dino.sprite.scaleX(-1);
  })();

  if (SHOW_HITBOX) {
    dino.hitbox = new Konva.Rect({
      x: dino.x - dino.hitW / 2,
      y: dino.y - dino.hitH,
      width: dino.hitW,
      height: dino.hitH,
      stroke: 'rgba(0,200,0,0.9)',
      strokeWidth: 2,
    });
    gameLayer.add(dino.hitbox);
  }

  function updateDinoNodes() {
    // group çš„ (x,y) å°±æ˜¯è…³åº•ä½ç½®
    dino.group.position({
      x: dino.x,
      y: dino.y,
    });

    // åœ¨åœ°ä¸Šæ™‚å·¦å³æ™ƒå‹•ï¼Œè·³èµ·ä¾†å°±ç«™ç›´
    const tilt = dino.onGround ? Math.sin(runPhase) * 8 : 0; // 8åº¦å¯å†èª¿
    dino.group.rotation(tilt);

    if (SHOW_HITBOX && dino.hitbox) {
      dino.hitbox.position({
        x: dino.x - dino.hitW / 3,  // ä½ æ ¡æ­£å¥½çš„åç§»
        y: dino.y - dino.hitH,
      });
    }
  }

  // ===== éšœç¤™ç‰©ï¼ˆğŸŒµ / ğŸ›¸ï¼‰ =====
  let obstacles = []; // { x, y, fontSize, hitW, hitH, sprite, hitbox, type }

  function spawnObstacle() {
    const isUfo = Math.random() < 0.35;
    let emojiChar, y, fontSize, type;

    fontSize = 40;

    if (isUfo) {
      emojiChar = 'ğŸ›¸';
      y = GROUND_Y - 80;
      type = 'ufo';
    } else {
      emojiChar = 'ğŸŒµ';
      y = GROUND_Y;
      type = 'cactus';
    }

    const hitW = 40;
    const hitH = 40;
    const x = GAME_W + fontSize; // å¾å³å´å¤–é¢å‡ºç¾

    const sprite = new Konva.Text({
      x: x - fontSize / 2,
      y: y - fontSize,
      text: emojiChar,
      fontSize,
      fontFamily: EMOJI_FONT,
    });
    gameLayer.add(sprite);

    // æ°´å¹³é¡åƒ ğŸ›¸
    if (type === 'ufo') {
      const w = sprite.width();
      sprite.offsetX(w);
      sprite.scaleX(-1);
    }

    let hitbox = null;
    if (SHOW_HITBOX) {
      hitbox = new Konva.Rect({
        x: x - hitW / 2,
        y: y - hitH,
        width: hitW,
        height: hitH,
        stroke: 'rgba(220,0,0,0.9)',
        strokeWidth: 2,
      });
      gameLayer.add(hitbox);
    }

    obstacles.push({
      x,
      y,
      fontSize,
      hitW,
      hitH,
      sprite,
      hitbox,
      type,
    });
  }

  // ===== ç¢°æ’å·¥å…· =====
  function getRect(obj) {
    const w = obj.hitW;
    const h = obj.hitH;
    return {
      left: obj.x - w / 2,
      right: obj.x + w / 2,
      top: obj.y - h,
      bottom: obj.y,
    };
  }

  function checkCollision(a, b) {
    const ra = getRect(a);
    const rb = getRect(b);
    return !(
      ra.right < rb.left ||
      ra.left > rb.right ||
      ra.bottom < rb.top ||
      ra.top > rb.bottom
    );
  }

  // ===== åˆ†æ•¸é¡¯ç¤º =====
  let score = 0;
  let frameCount = 0;
  let gameState = 'playing'; // 'playing' | 'gameover'

  const scoreText = new Konva.Text({
    x: GAME_W - 10,
    y: 10,
    text: 'Score: 0',
    fontSize: 18,
    fontFamily: 'Arial, sans-serif',
    fill: '#555',
    align: 'right',
  });
  scoreText.offsetX(scoreText.width());
  gameLayer.add(scoreText);

  // ===== Game Over ç•«é¢ =====
  const gameOverGroup = new Konva.Group({
    x: GAME_W / 2,
    y: GAME_H / 2,
    visible: false,
  });

  const gameOverBg = new Konva.Rect({
    x: -160,
    y: -60,
    width: 320,
    height: 120,
    fill: 'rgba(0,0,0,0.7)',
    cornerRadius: 12,
  });

  const gameOverTitle = new Konva.Text({
    x: -150,
    y: -40,
    width: 300,
    align: 'center',
    text: 'GAME OVER',
    fontSize: 28,
    fontFamily: 'Arial, sans-serif',
    fill: '#fff',
  });

  const gameOverHint = new Konva.Text({
    x: -150,
    y: 0,
    width: 300,
    align: 'center',
    text: 'æŒ‰ â¬†ï¸ æˆ–ç©ºç™½éµé‡æ–°é–‹å§‹',
    fontSize: 16,
    fontFamily: 'Arial, sans-serif',
    fill: '#eee',
  });

  gameOverGroup.add(gameOverBg);
  gameOverGroup.add(gameOverTitle);
  gameOverGroup.add(gameOverHint);
  uiLayer.add(gameOverGroup);

  // ===== è·³èºé‚è¼¯ =====
  function doJump() {
    if (gameState === 'gameover') {
      resetGame();
    } else if (dino.onGround) {
      dino.vy = JUMP_VELOCITY;
      dino.onGround = false;
    }
  }

  // ===== å·¦ä¸‹è§’ â¬†ï¸ emoji æŒ‰éˆ•ï¼ˆæ”¾å¤§ç‰ˆï¼‰ =====
  const jumpButton = new Konva.Text({
    x: 40,
    y: GAME_H - 120,   // ç¨å¾®å¾€ä¸Šï¼Œé¿å…æ“‹åˆ°ä¸»è§’
    text: 'â¬†ï¸',
    fontSize: 72,
    fontFamily: EMOJI_FONT,
  });
  uiLayer.add(jumpButton);

  jumpButton.on('mousedown touchstart', (e) => {
    doJump();
    e.evt.preventDefault();
  });

  // éµç›¤æ§åˆ¶
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
      doJump();
      e.preventDefault();
    }
  });

  // ===== é‡ç½®éŠæˆ² =====
  function resetGame() {
    gameState = 'playing';
    score = 0;
    frameCount = 0;

    obstacles.forEach((obs) => {
      obs.sprite.destroy();
      if (obs.hitbox) obs.hitbox.destroy();
    });
    obstacles = [];

    dino.x = 220;
    dino.y = GROUND_Y;
    dino.vy = 0;
    dino.onGround = true;
    runPhase = 0;

    scoreText.text('Score: 0');
    gameOverGroup.visible(false);

    updateDinoNodes();
    gameLayer.batchDraw();
    uiLayer.batchDraw();
  }

  // ===== éŠæˆ²ä¸»è¿´åœˆ =====
  function update() {
    if (gameState !== 'playing') return;

    frameCount++;
    score += 1;
    scoreText.text('Score: ' + score);

    // ç”¢ç”Ÿéšœç¤™ç‰©ï¼ˆå¸¶ä¸€é»éš¨æ©Ÿï¼‰
    if (frameCount % 80 === 0 && Math.random() < 0.7) {
      spawnObstacle();
    }

    // æé¾ç‰©ç†
    dino.y += dino.vy;
    dino.vy += GRAVITY;
    if (dino.y >= GROUND_Y) {
      dino.y = GROUND_Y;
      dino.vy = 0;
      dino.onGround = true;
    } else {
      dino.onGround = false;
    }

    // åœ¨åœ°é¢æ™‚è®“æé¾å·¦å³å°å¹…åº¦æ“ºå‹•
    if (dino.onGround && gameState === 'playing') {
      runPhase += 0.4;  // è¶Šå¤§è·‘å¾—è¶Šã€Œæ€¥ã€
    } else {
      runPhase = 0;
    }

    updateDinoNodes();

    // éšœç¤™ç‰©ç§»å‹• + ç¢°æ’
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs = obstacles[i];
      obs.x -= GAME_SPEED;

      obs.sprite.position({
        x: obs.x - obs.fontSize / 2,
        y: obs.y - obs.fontSize,
      });

      if (SHOW_HITBOX && obs.hitbox) {
        obs.hitbox.position({
          x: obs.x - obs.hitW / 3,
          y: obs.y - obs.hitH,
        });
      }

      // è¶…å‡ºå·¦é‚Šåˆªé™¤
      if (obs.x + obs.fontSize / 2 < 0) {
        obs.sprite.destroy();
        if (obs.hitbox) obs.hitbox.destroy();
        obstacles.splice(i, 1);
        continue;
      }

      // ç¢°æ’åˆ¤å®š
      if (checkCollision(dino, obs)) {
        gameState = 'gameover';
        gameOverGroup.visible(true);
        break;
      }
    }
  }

  function loop() {
    update();
    gameLayer.batchDraw();
    uiLayer.batchDraw();
    requestAnimationFrame(loop);
  }

  // ===== éŸ¿æ‡‰å¼ç¸®æ”¾ï¼šç¶­æŒ 16:9ï¼Œç­‰æ¯”ä¾‹æ”¾å¤§ä¸¦ç½®ä¸­ =====
  function fitStageIntoWindow() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    const scale = Math.min(w / GAME_W, h / GAME_H);
    const newWidth  = GAME_W * scale;
    const newHeight = GAME_H * scale;

    stage.width(newWidth);
    stage.height(newHeight);
    stage.scale({ x: scale, y: scale });

    container.style.width  = newWidth + 'px';
    container.style.height = newHeight + 'px';

    stage.draw();
  }

  window.addEventListener('resize', fitStageIntoWindow);

  // å•Ÿå‹•
  resetGame();
  fitStageIntoWindow();
  loop();
</script>
</body>
</html>
